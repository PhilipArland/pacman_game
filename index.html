<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Canvas</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
        }

        .game-container {
            background-color: #111;
            box-shadow: 0 0 25px rgba(0, 0, 255, 0.7);
            max-width: 800px;
            width: 100%;
            border-radius: 15px;
            padding: 15px;
        }

        canvas {
            display: block;
            margin: 0 auto;
            border: 3px solid #ffc107;
            background-color: #000;
            width: 100%;
            height: 70vh;
            border-radius: .75rem;
        }

        .arcade-modal {
            background-color: #111;
            border: 3px solid #ffc107;
            border-radius: 15px;
            box-shadow: 0 0 20px #ffc107, 0 0 40px #00f, 0 0 60px #f0f;
            font-family: 'Press Start 2P', cursive;
        }

        .arcade-modal .modal-title {
            text-shadow: 0 0 5px #ffc107, 0 0 10px #ff0;
        }

        .arcade-modal p {
            font-size: 1rem;
            text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
        }

        #restartBtn {
            text-shadow: 0 0 5px #ff0, 0 0 10px #f0f;
        }
    </style>
</head>

<body>
    <div class="container game-container">
        <!-- Header -->
        <div class="game-header d-flex align-items-center justify-content-between mb-3">
            <div class="title d-flex gap-3 align-items-center">
                <img src="pac.gif" class="img-fluid" style="max-height:50px;" alt="Pacman">
                <h1 class="fw-bold text-warning mb-0">PAC-MAN</h1>
            </div>
            <div class="scores d-flex gap-3">
                <h5 class="text-info mb-0">Score: <span id="score">0</span></h5>
                <h5 class="text-danger mb-0">Lives: <span id="lives">3</span></h5>
            </div>
        </div>

        <!-- Canvas -->
        <canvas id="gameCanvas"></canvas>

        <!-- Footer -->
        <div class="text-center mt-3">
            <p class="text-light small">Use arrow keys or WASD to move Pac-Man</p>
            <button id="startBtn" class="btn btn-warning fw-bold px-4">Start Game</button>
        </div>
    </div>

    <!-- Game Over Modal -->
    <div class="modal fade" id="gameModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content arcade-modal">
                <div class="modal-header border-0 justify-content-center">
                    <h5 class="modal-title text-warning text-center" id="modalTitle">You Died!</h5>
                </div>
                <div class="modal-body text-center text-info">
                    <p id="modalMessage">Try Again!</p>
                    <button id="restartBtn" class="btn btn-warning fw-bold mt-2">Restart</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirm Restart Modal -->
    <div class="modal fade" id="confirmModal" tabindex="-1" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content arcade-modal">
                <div class="modal-header border-0 justify-content-center">
                    <h5 class="modal-title text-warning text-center">Restart Game?</h5>
                </div>
                <div class="modal-body text-center text-info">
                    <p>Are you sure you want to restart?</p>
                    <button id="confirmYes" class="btn btn-warning fw-bold mt-2 me-2">Yes</button>
                    <button id="confirmCancel" class="btn btn-secondary fw-bold mt-2">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        window.addEventListener('DOMContentLoaded', () => {
            const CELL_SIZE = 30;
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            const startBtn = document.getElementById('startBtn');
            const restartBtn = document.getElementById('restartBtn');
            const confirmYes = document.getElementById('confirmYes');
            const confirmCancel = document.getElementById('confirmCancel');

            const gameModal = new bootstrap.Modal(document.getElementById('gameModal'));
            const confirmModal = new bootstrap.Modal(document.getElementById('confirmModal'));

            const originalMaze = [
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 0, 0, 1, 3, 3, 3, 1, 2, 0, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 1, 0, 1, 1, 1, 3, 3, 3, 1, 1, 1, 0, 1, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 3, 3, 3, 3, 3, 3, 3, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 2, 1, 0, 1, 3, 3, 3, 3, 3, 3, 3, 1, 0, 1, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1],
                [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ];
            let maze = JSON.parse(JSON.stringify(originalMaze));

            const rows = maze.length;
            const cols = maze[0].length;

            const pacman = { row: 1, col: 1, direction: 'right', nextDirection: 'right', mouthAngle: 0, mouthDir: 1 };
            let ghosts = [
                { row: 4, col: 9, color: 'red', direction: 'left', mode: 'scatter' },
                { row: 4, col: 11, color: 'pink', direction: 'right', mode: 'scatter' },
                { row: 5, col: 9, color: 'cyan', direction: 'up', mode: 'scatter' },
                { row: 5, col: 11, color: 'orange', direction: 'down', mode: 'scatter' }
            ];
            let ghostIdleOffsets = ghosts.map(() => ({ x: 0, y: 0 }));
            let frameCount = 0;
            const moveSpeed = 10;
            let powerMode = false;
            let powerModeTimer = 0;
            let gameRunning = false;
            let countdown = 0;
            let lives = 3;
            let score = 0;

            // --- Controls ---
            window.addEventListener('keydown', e => {
                switch (e.key) {
                    case 'ArrowUp': case 'w': case 'W': pacman.nextDirection = 'up'; break;
                    case 'ArrowDown': case 's': case 'S': pacman.nextDirection = 'down'; break;
                    case 'ArrowLeft': case 'a': case 'A': pacman.nextDirection = 'left'; break;
                    case 'ArrowRight': case 'd': case 'D': pacman.nextDirection = 'right'; break;
                }
            });

            // --- Canvas Resize ---
            function resizeCanvas() {
                canvas.width = canvas.clientWidth;
                canvas.height = canvas.clientHeight;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // --- Game Reset ---
            function resetGame() {
                pacman.row = 1; pacman.col = 1; pacman.direction = 'right'; pacman.nextDirection = 'right';
                ghosts = [
                    { row: 4, col: 9, color: 'red', direction: 'left', mode: 'scatter' },
                    { row: 4, col: 11, color: 'pink', direction: 'right', mode: 'scatter' },
                    { row: 5, col: 9, color: 'cyan', direction: 'up', mode: 'scatter' },
                    { row: 5, col: 11, color: 'orange', direction: 'down', mode: 'scatter' }
                ];
                ghostIdleOffsets = ghosts.map(() => ({ x: 0, y: 0 }));
                maze = JSON.parse(JSON.stringify(originalMaze));
                lives = 3; score = 0; powerMode = false; powerModeTimer = 0; gameRunning = false; countdown = 0;
                updateScore(); updateLives();
            }

            // --- Update Score & Lives ---
            function updateScore() { document.getElementById('score').innerText = score; }
            function updateLives() { document.getElementById('lives').innerText = lives; }

            // --- Show Game Modal ---
            function showModal(title, message) {
                document.getElementById('modalTitle').innerText = title;
                document.getElementById('modalMessage').innerText = message;
                gameModal.show(); // use the correct instance
            }

            // --- Start Button ---
            startBtn.addEventListener('click', () => {
                if (!gameRunning && countdown === 0) {
                    countdown = 3;
                    frameCount = 0;
                    startBtn.disabled = true;
                    startBtn.innerText = 'Get Ready...';
                } else if (gameRunning) {
                    gameRunning = false;
                    confirmModal.show();
                }
            });

            restartBtn.addEventListener('click', () => {
                resetGame();
                countdown = 3;
                frameCount = 0;
                startBtn.disabled = true;
                startBtn.innerText = 'Get Ready...';
                gameModal.hide(); // now hides correctly
            });

            confirmYes.addEventListener('click', () => {
                resetGame();
                countdown = 3;
                frameCount = 0;
                startBtn.disabled = true;
                startBtn.innerText = 'Get Ready...';
                confirmModal.hide();
            });

            confirmCancel.addEventListener('click', () => {
                gameRunning = true;
                confirmModal.hide();
            });

            // --- Utility functions for movement and collision (same as your original code) ---
            function canMove(r, c) { return maze[r] && maze[r][c] !== 1; }
            function movePacman() {
                let nr = pacman.row, nc = pacman.col;
                switch (pacman.nextDirection) {
                    case 'up': if (canMove(nr - 1, nc)) { nr--; pacman.direction = 'up'; } break;
                    case 'down': if (canMove(nr + 1, nc)) { nr++; pacman.direction = 'down'; } break;
                    case 'left': if (canMove(nr, nc - 1)) { nc--; pacman.direction = 'left'; } break;
                    case 'right': if (canMove(nr, nc + 1)) { nc++; pacman.direction = 'right'; } break;
                }
                pacman.row = nr; pacman.col = nc;
                const cell = maze[nr][nc];
                if (cell === 0) { maze[nr][nc] = 3; score += 10; }
                if (cell === 2) { maze[nr][nc] = 3; powerMode = true; powerModeTimer = 300; score += 50; }
            }

            function moveGhosts() {
                ghosts.forEach(g => {
                    const moves = [];
                    if (canMove(g.row - 1, g.col) && g.direction !== 'down') moves.push('up');
                    if (canMove(g.row + 1, g.col) && g.direction !== 'up') moves.push('down');
                    if (canMove(g.row, g.col - 1) && g.direction !== 'right') moves.push('left');
                    if (canMove(g.row, g.col + 1) && g.direction !== 'left') moves.push('right');

                    if (gameRunning) {
                        let chosenDir = moves[Math.floor(Math.random() * moves.length)];
                        let bestScore = powerMode ? -Infinity : Infinity;

                        moves.forEach(dir => {
                            let r = g.row, c = g.col;
                            if (dir === 'up') r--;
                            if (dir === 'down') r++;
                            if (dir === 'left') c--;
                            if (dir === 'right') c++;

                            const dist = Math.abs(r - pacman.row) + Math.abs(c - pacman.col);

                            if (!powerMode) {
                                // Normal mode: choose closest (chase)
                                if (dist < bestScore) { bestScore = dist; chosenDir = dir; }
                            } else {
                                // Power mode: choose farthest (flee)
                                if (dist > bestScore) { bestScore = dist; chosenDir = dir; }
                            }
                        });

                        g.direction = chosenDir;

                        switch (g.direction) {
                            case 'up': g.row--; break;
                            case 'down': g.row++; break;
                            case 'left': g.col--; break;
                            case 'right': g.col++; break;
                        }
                    }
                });
            }


            function checkGhostCollisions() {
                ghosts.forEach(g => {
                    if (g.row === pacman.row && g.col === pacman.col) {
                        if (powerMode) { g.row = -1; g.col = -1; score += 200; }
                        else {
                            lives--;
                            updateLives();
                            if (lives <= 0) {
                                gameRunning = false;
                                showModal("You Died!", "Try Again!");
                            } else {
                                pacman.row = 1;
                                pacman.col = 1;
                            }
                        }
                    }
                });
            }

            function allDotsEaten() {
                return maze.flat().every(c => c !== 0 && c !== 2);
            }

            function updatePacmanMouth() {
                pacman.mouthAngle += pacman.mouthDir * 0.05;
                if (pacman.mouthAngle > Math.PI * 0.2) pacman.mouthDir = -1;
                if (pacman.mouthAngle < 0) pacman.mouthDir = 1;
            }

            function drawMaze(cellSizeX, cellSizeY) {
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cell = maze[r][c];
                        ctx.fillStyle = '#000';
                        ctx.fillRect(c * cellSizeX, r * cellSizeY, cellSizeX, cellSizeY);
                        if (cell === 1) ctx.fillStyle = '#0000ff';
                        else if (cell === 0 || cell === 2) ctx.fillStyle = '#ffc107';
                        if (cell === 0 || cell === 2) {
                            ctx.beginPath();
                            const radius = cell === 0 ? Math.min(cellSizeX, cellSizeY) / 6 : Math.min(cellSizeX, cellSizeY) / 3;
                            ctx.arc(c * cellSizeX + cellSizeX / 2, r * cellSizeY + cellSizeY / 2, radius, 0, Math.PI * 2);
                            ctx.fill();
                        } else if (cell === 1) {
                            ctx.fillRect(c * cellSizeX, r * cellSizeY, cellSizeX, cellSizeY);
                        }
                    }
                }
            }

            function drawPacman(cellSizeX, cellSizeY) {
                const cx = pacman.col * cellSizeX + cellSizeX / 2;
                const cy = pacman.row * cellSizeY + cellSizeY / 2;
                const r = Math.min(cellSizeX, cellSizeY) / 2 * 0.9;
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                let start, end;
                switch (pacman.direction) {
                    case 'right': start = pacman.mouthAngle; end = 2 * Math.PI - pacman.mouthAngle; break;
                    case 'left': start = Math.PI + pacman.mouthAngle; end = Math.PI - pacman.mouthAngle; break;
                    case 'up': start = 1.5 * Math.PI + pacman.mouthAngle; end = 1.5 * Math.PI - pacman.mouthAngle; break;
                    case 'down': start = 0.5 * Math.PI + pacman.mouthAngle; end = 0.5 * Math.PI - pacman.mouthAngle; break;
                }
                ctx.moveTo(cx, cy);
                ctx.arc(cx, cy, r, start, end, false);
                ctx.closePath();
                ctx.fill();
            }

            function drawGhosts(cellSizeX, cellSizeY) {
                ghosts.forEach((g, i) => {
                    let offsetX = 0, offsetY = 0;

                    // Apply idle animation if game isn't actively running
                    if (!gameRunning || countdown > 0) {
                        offsetX = Math.sin(frameCount * 0.05 + i) * 3;
                        offsetY = Math.cos(frameCount * 0.05 + i) * 2;
                        ghostIdleOffsets[i] = { x: offsetX, y: offsetY };
                    } else {
                        // Use last idle offset while moving
                        offsetX = ghostIdleOffsets[i].x;
                        offsetY = ghostIdleOffsets[i].y;
                    }

                    const x = g.col * cellSizeX + cellSizeX / 2 + offsetX;
                    const y = g.row * cellSizeY + cellSizeY / 2 + offsetY;

                    ctx.fillStyle = powerMode ? '#0000ff' : g.color;

                    // Draw ghost body
                    ctx.beginPath();
                    ctx.arc(x, y - 2, CELL_SIZE / 2 - 2, Math.PI, 0);
                    ctx.fillRect(x - CELL_SIZE / 2 + 2, y - 2, CELL_SIZE - 4, CELL_SIZE / 2);

                    // Draw ghost teeth
                    const toothWidth = (CELL_SIZE - 4) / 4;
                    for (let t = 0; t < 4; t++) {
                        if (t % 2 === 0) ctx.fillRect(x - CELL_SIZE / 2 + 2 + t * toothWidth, y + CELL_SIZE / 2 - 4, toothWidth, 4);
                    }
                    ctx.fill();

                    // Draw eyes
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(x - 6, y - 8, 4, 4);
                    ctx.fillRect(x + 2, y - 8, 4, 4);

                    ctx.fillStyle = '#000';
                    ctx.fillRect(x - 5, y - 7, 2, 2);
                    ctx.fillRect(x + 3, y - 7, 2, 2);
                });
            }


            // --- Main Game Loop ---
            function gameLoop() {
                const cellSizeX = canvas.width / cols;
                const cellSizeY = canvas.height / rows;
                frameCount++;

                updatePacmanMouth();

                if (countdown > 0 && frameCount % 60 === 0) {
                    countdown--;
                    if (countdown === 0) {
                        gameRunning = true;
                        startBtn.disabled = false;
                        startBtn.innerText = 'Restart Game';
                    }
                }

                if (gameRunning && countdown === 0 && frameCount % moveSpeed === 0) {
                    movePacman();
                    moveGhosts();
                    checkGhostCollisions();
                }

                if (powerMode) {
                    powerModeTimer--;
                    if (powerModeTimer <= 0) powerMode = false;
                }

                drawMaze(cellSizeX, cellSizeY);
                drawPacman(cellSizeX, cellSizeY);
                drawGhosts(cellSizeX, cellSizeY);

                if (!gameRunning || countdown > 0) {
                    ctx.fillStyle = '#ff0';
                    ctx.font = `${cellSizeY}px 'Press Start 2P'`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const offsetX = 10;  // move right
                    const offsetY = 20;  // move down
                    const text = countdown > 0 ? countdown : 'READY!';
                    ctx.fillText(text, canvas.width / 2 + offsetX, canvas.height / 2 + offsetY);
                }


                updateScore();
                updateLives();

                if (allDotsEaten() && gameRunning) {
                    gameRunning = false;
                    showModal("Congratulations!", "You cleared all dots!");
                }

                requestAnimationFrame(gameLoop);
            }

            gameLoop();
        });
    </script>
</body>

</html>